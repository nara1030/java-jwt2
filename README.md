## 목표
```txt
1. 로그인한 사용자에 따라 서로 다른 메뉴가 노출된다.
   (시큐리티 기본 폼 로그인 양식 사용)
2. 로그인 성공 이후 JWT 토큰이 발급되고, 이후 타 API에 대해서는 토큰 검증 후 접근 허용된다.
```

## 기록
```txt
먼저 스프링 시큐리티 설정에 대해서..

1. 폼 로그인 방식을 선택했기에, UsernamePasswordAuthenticationFilter가 실행된다.
   다만, 폼 로그인 방식임에도 로그인 성공 시 토큰 발급하므로 세션 기반 로그인 방식은 아니다.
2. 로그인 성공 후 JWT 발급, URL 접근 시 JWT 여부 검증 위해 Filter 추가한다.
   전자는 로그인 필터 뒤, 후자는 앞에 두어서 로그인 필터가 인증 사용자에 대해 중복 처리하지 않도록 하였다.
   이 과정들은 꼭 Filter가 아니더라도 Provider를 커스터마이징할 수도 있다고 알고 있으나, 좀 더 흔한 방식을 택했다[A].
3. 토큰 검증 시 토큰 내 사용자명이 있는지, 유효한 토큰인지만 확인했다.
   토큰, SecurityContext에 대한 지식이 부족해서 최초엔 토큰 검증 로직[B]에서 SecurityContextHolder를 이용했다.
   하지만 SecurityContext는 각 요청에 대해 독립적(thread-local)이며, 요청이 종료되면 유효하지 않아 세션과는 다르다는 걸 런타임 에러가 터지고 다시 인지했다.

메뉴, 그리고 타임리프에 관해서는..

1. 흔히 관계형 DB로 권한에 대해 관리했었는데, 공통 작업을 해본 적이 없기도 하고 이를 시큐리티와 연동해보고 싶었다.
   관계형 DB라면 ROLE, USER, MENU 이렇게 분리하여 ROLE에 코드성 데이터를 놨을 거 같은데..
   ROLE을 ENUM으로 뺀 후 DB 사용은 조금 번잡할 거 같아서 USER, MENU 데이터는 JSON 파일로 로드했다.
   이때 ENUM에 커스텀하게 권한을 추가하고, 시큐리티에서 그걸 연동하고 싶었다[C][D].
2. 최초 페이지(/)에서 유저와 방문객이 보는 메뉴를 다르게 노출하고 싶었다.
   처음 생각은 모든 메뉴를 페이지에 뿌리고, 화면단에서 ROLE 정보를 받아 노출을 제어하고 싶었다.
   그런데 타임리프에서 hasRole 함수 내부에 동적 파라미터 전달에서 에러가 발생하여[E],
   차선책으로 서버에서 유저 권한에 따라 메뉴를 필터링해서 뿌려주도록 하였다[F].

미비하여 추후 공부할 부분..
(적용 여부 O△X 표시)

1O. 현재 컨트롤러에서 반환하는 페이지에 중복되는 부분이 많다.
    따라서 타임리프 레이아웃을 이용해 공통 부분(사용자 노출, 사이드바 메뉴)을 추출해보자.
    → 타임리프 레이아웃 사용하여 해봤는데, 서버에서 넘어오는 데이터를 화면간 어떻게 공유/이동시키는지 확실히 이해 안 간다.
      CSS를 잘 못하고, 공통화 부분도 잘은 몰라서 화면상에서 깔끔하게 노출되진 않는 상태다.
2△. JWT 발급 이후 로그인 테스트해보려다 중지했다.
    현재 로그인/로그아웃은 구현되어 있으나 로그인시 해당 유저 권한에 따른 메뉴 노출이 안 되고 있고,
    또한 시큐리티 설정에서 세션 기반 인증 비활성화하여 /test 등 API 접근 시 토큰 같이 보내주지 않아 /login으로 리다이렉트된다.
    --
    구분해서 얘기하면, 이 서버는 세션 기반 인증/인가 서버라고 할 수 있다.
    앞에서 세션 기반 아니라고 했는데, 그건 로그인 이후 리소스 서버에 접근할 때 토큰을 담아서 하기 때문에 그렇게 생각했는데,
    여기에 리소스 서버 용도로 테스트까지 함께 진행하다가 꼬였다[G].
    다시 말해 서버에서 세션 기반 인증을 명시적으로 제거해주고, 프론트에서 상태 관리해주어야 하는데 상태 관리가 쉽지 않아 중지했다.
    그냥 이 부분은 토큰 발급 이후 POSTMAN으로 해당 토큰 담아서 보낼 때 서버 제대로 호출하는지 정도로 확인해야 할 거 같다.
3. 결국 리소스, 인증/인가 분리한다는 건 OAUTH2, MSA 이 개념인 거 같은데...
   이거 한 번 구현해봐야 할 거 같다.
   현재 개념적으로 좀 이해가 안 가는 부분은 인증/인가 서버가 발급한 토큰을 리소스 서버에서 어떤 식으로 검증할 거냐...  
4. 인증 프로세스가 복수 개 있을 수도 있다.
   예를 들어 폼 로그인 외 지문 로그인 등 선택할 수 있는 경우... 복수 개의 Provider로..
   폼 로그인의 경우도 2 Factor 인증(?)으로 폰 인증 로직도 추가할 수 있고..
5. 별개로 멀티모듈 한 번 해보려고 했으나..
   딱 어떤 상황에 써야 하는지 몰라서 안함..

기타 공부했던 부분..

1. JWT(JSON Web Token) 발급 시 토큰 앞에 Bearer라는 키워드 붙이는 이유가 무엇인가?
   - 이는 JWT 또는 다른 형태의 엑세스 토큰을 서버에 전달하는 표준적인 방식이다.
     Authorization: Bearer <token>
     다시 말해, OAuth2를 포함 많은 인증/권한 부여 시스템에서 Bearer 방식을 채택하고 있다.
   - 또한 상태를 유지하지 않는(stateless), 즉 RESTful API나 MSA 설계에 적합하다.
     RESTful API 디자인에서 인증 정보는 Authorization 헤더에 포함되는 것이 표준이다.
2. OAUTH2와 JWT의 차이점이 뭐야?
   - OAUTH2는 인증/권한 부여 프레임워크로, 사용자나 클라이언트(어플리케이션)가 특정 리소스에 접근할 수 있도록 권한을 부여하는 시스템이다.
     이때 사용자의 인증정보를 직접 제공하는 대신, 엑세스 토큰을 통해 간접적으로 리소스에 접근하도록 한다.
   - JWT는 JSON 형식의 토큰으로, 주로 인증 정보를 전송하기 위한 표준 포맷이다.
3. 기본적으로 스프링 시큐리티는 필터 기반으로 동작한다.
   개발자가 /login 혹은 /logout 처리를 컨트롤러에서 커스텀 처리 하더라도,
   스프링 시큐리티 설정에서 명시적으로 비활성화시켜주지 않는다면 컨트롤러까지 요청이 도달하지 않는다.
   예를 들어, 
     loginProcessingUrl 설정 같은 경우 폼 로그인 사용한다는 것이므로, 컨트롤러가 아닌 기본 필터가 처리를 담당한다.
     logout(AbstractHttpConfigurer::disable) 설정 또한 명시적으로 해주지 않으면 컨트롤러가 아닌 로그아웃 필터가 처리를 담당한다.
4. 필터를 Skip하고 Controller로 가는 방법은 없는 것 같다.
   스프링 시큐리티에서 기본 필터 사용 로그인 시, 컨트롤러에서 로그인 시 각각 흐름은 다음과 같다.
   플로우 비교
     시큐리티 로그인 사용: JwtAutehnticationFilter > UsernamePasswordAuthenticationFilter > JwtGenerationFilter
     커스텀 로그인 사용: JwtAutehnticationFilter > JwtGenerationFilter > LoginController
   커스텀 로그인 테스트로 검증된 토큰의 경우 토큰 다음 단계를 건너 뛰고자 바로 컨트롤러(임의의 API)로 이동하고자
   return문을 사용했으나 아예 다음 단계가 모두 실행이 안 되었다.
   (return문을 쓰더라도 filterChain.doFilter 메소드 호출 뒤에 호출하고, 해당 필터의 실행 유무는 그 필터에서 분기 걸어줬다.)
   참고로 permitAll 메소드의 경우, Spring Security에서 인증 관련 필터가 동작하지 않도록 처리한다고 한다.
   (다만, JwtAuthenticationFilter와 같은 커스텀 필터 등 인증 외 작업을 처리하는 필터는 여전히 동작한다.)
5. Resolved [org.springframework.web.HttpMediaTypeNotAcceptableException: No acceptable representation]
   작은 부분인데 클라이언트에서 response.json() 사용하려면,
   응답으로 반환해주는 DTO에서 GETTER가 필수이다.

----
A. Provider를 여러 개 두어서 인증 시 비밀번호, 지문 등 여러 개를 놔둘 수도 있다고 하는데 이는 추후 구현해보고 싶다.
   support 등 메소드 사용법 정확히 몰라서..
B. 토큰 기반인데, 토큰 검증 및 로그인 이후에 SecurityContext에 Authentication 저장할 필요가 있을까 싶었는데,
   많은 예제에서 그렇게 해주는 걸 보고 찾아보니 다음 이유가 있었다.
     SecurityContextHolder에 저장된 정보는 Spring Security의
       필터 체인이나 서비스, 컨트롤러에서 자동으로 참조하므로 데이터 일관성을 위해 저장
     Spring Security의 어노테이션 기반 권한 부여(@PreAuthorize, @Secured 등)는
       SecurityContextHolder에 저장된 인증 정보를 바탕으로 동작
       (Authentication 객체가 저장되어 있어야 해당 기능들이 제대로 작동)
C. 현재 4개의 권한이 있고, 방문객 권한으로 ANONYMOUS가 있는데 이는 원래 UNREGISTERED였다.
   시큐리티가 ANONYMOUS가 아니면 못 읽는 거 같아서 수정해주었는데 원래 하고 싶었던 건 아니었다...
D. 용어가 맞는지 모르겠으나, 역할보다 세부적인 권한 정보(WRITE, READ 등)도 사용해보고 싶다.
   SI하면 이벤트 버튼 등에 사용자마다 권한이 다르게 들어가 있는 경우가 있던데..
   정확히 언제 필요했는지 떠오르지가 않네..
E. sec:authorize 태그에서 hasRole 함수 내부에 동적 파라미터를 전달하는 것은 불가능하다고 Chat GPT가..
F. 이 로직도 Chat GPT 도움을 받긴 했는데, 더 간단하게 짤 수 있나 싶기도 하고..
G. 기본적으로 스프링 부트에서 시큐리티 의존성 사용 시 디폴트 세팅되는 게 있는 거 같다.
   예를 들어 시큐리티 설정에서 formLogin 설정을 해주면 해당 로그인 필터를 타고,
   마찬가지로 기본 로그아웃 비활성화 처리해주지 않으면 세션기반 로그아웃 필터가 처리를 가로챈다.
   인증/인가가 필요한 페이지에 접근 제한이나 리다이렉트 같은 부분도 formLogin 기본 세팅되는 부분이다.
   참고로 타임리프의 sec:authentication="name" 같은 구문도 시큐리티의 세션 기반 인증을 사용하는 방식이다.

```




